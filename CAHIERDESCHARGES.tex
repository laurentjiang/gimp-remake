\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[default]{montserrat}

% Configuration de la mise en page
\geometry{hmargin=2.5cm,vmargin=2.5cm}

% Espacement plus aéré pour les sections
\titlespacing*{\section}{0pt}{4em}{2em}

\title{\textbf{Cahier des Charges}\\Projet GIMP Remake}
\author{Équipe de Développement}
\date{\today}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Présentation du Projet}

\subsection{Contexte}
Le projet \textbf{GIMP Remake} est une réimplémentation complète ("from scratch") du célèbre logiciel de retouche d'image GIMP (GNU Image Manipulation Program). Contrairement au projet original écrit en C avec la bibliothèque GTK, cette refonte s'appuie sur des technologies modernes : C++20, le framework applicatif Qt6 et le moteur de rendu Skia.

Ce projet ne consiste pas à créer une simple interface ("wrapper") autour du code existant de GIMP, mais bien à reconstruire l'architecture logicielle en utilisant des paradigmes de programmation modernes et orientés objet.

\subsection{Nature du Logiciel}
Il s'agit d'une application de bureau ("Desktop Application") multiplateforme destinée à la création graphique, la retouche photo et la composition d'images. Le logiciel se veut performant grâce à l'accélération matérielle (GPU) et modulaire.

\subsection{Public Cible}
\begin{itemize}
    \item \textbf{Utilisateurs finaux :} Graphistes, photographes et amateurs souhaitant un outil de retouche performant et réactif.
    \item \textbf{Développeurs et Étudiants :} Le projet sert également de démonstrateur technique pour l'apprentissage de l'architecture logicielle complexe (C++20, Design Patterns, Gestion mémoire).
\end{itemize}

\section{Objectifs du Projet}

\subsection{Objectifs Pédagogiques}
Le projet vise à servir de cas d'école pour comprendre comment se construit un éditeur d'image complexe. Il met l'accent sur :
\begin{itemize}
    \item L'application des principes \textbf{RAII} (Resource Acquisition Is Initialization) et de la gestion mémoire moderne.
    \item L'implémentation de \textbf{Design Patterns} classiques (Command, Strategy, Observer, Factory).
    \item La compréhension des pipelines de rendu graphique et des algorithmes de traitement d'image.
\end{itemize}

\newpage
\subsection{Objectifs Techniques}
\begin{itemize}
    \item \textbf{Modernisation :} Utiliser exclusivement C++20 (Ranges, Concepts).
    \item \textbf{Performance :} Utiliser Skia pour un rendu accéléré par le GPU, offrant une fluidité supérieure lors des zooms et des déplacements sur le canevas.
    \item \textbf{Maintenabilité :} Une architecture en couches (Layered Architecture) claire, découplant l'interface utilisateur de la logique métier.
    \item \textbf{Indépendance :} S'affranchir de la complexité de l'écosystème GLib/GTK original pour une intégration native Qt.
\end{itemize}

\section{Fonctionnalités Cœur}

\subsection{Interface Utilisateur (UI)}
L'interface reprend les standards ergonomiques des logiciels de retouche (type Photoshop/GIMP) :
\begin{itemize}
    \item Système de panneaux ancrables ("Docking Layout") : Boîte à outils, Calques, Historique.
    \item Thème sombre moderne adapté à la création graphique.
    \item Palette de commandes ("Command Palette") pour un accès rapide aux fonctions.
    \item Overlay de débogage (HUD) affichant les performances (FPS, mémoire).
\end{itemize}

\subsection{Outils de Création}
\begin{itemize}
    \item \textbf{Dessin :} Pinceau (Brush) avec dynamique de vélocité, Crayon (Pencil) pixel-perfect, Gomme (Eraser).
    \item \textbf{Remplissage :} Outil Pot de peinture (Bucket Fill) et Dégradés (Linéaire, Radial).
    \item \textbf{Sélection :} Rectangle, Ellipse, Lasso (Sélection libre). Support des opérations d'ajout/soustraction.
    \item \textbf{Pipette :} Sélection de couleur sur le canevas.
\end{itemize}

\subsection{Gestion des Calques}
Système complet d'empilement de calques ("Layer Stack") supportant :
\begin{itemize}
    \item Visibilité et opacité par calque.
    \item Modes de fusion (Normal, Multiply, Screen, Overlay, etc.).
    \item Réorganisation de la pile de calques.
\end{itemize}

\subsection{Traitement d'Image}
Application de filtres destructifs sur les calques :
\begin{itemize}
    \item Flou Gaussien (Gaussian Blur).
    \item Accentuation de netteté (Unsharp Masking).
\end{itemize}

\section{Spécifications Techniques}

\subsection{Stack Technologique}
\begin{itemize}
    \item \textbf{Langage :} C++20.
    \item \textbf{UI Framework :} Qt6 (Widgets + SVG).
    \item \textbf{Moteur de Rendu :} Skia (Google).
    \item \textbf{I/O Image :} OpenCV (chargement/sauvegarde de fichiers standards).
    \item \textbf{Logging :} spdlog.
    \item \textbf{Build System :} CMake + Ninja.
    \item \textbf{Gestionnaire de paquets :} vcpkg (Manifest mode).
\end{itemize}

\subsection{Architecture Logicielle}
Le projet suit une architecture en couches stricte :
\begin{enumerate}
    \item \textbf{UI Layer :} `MainWindow`, `SkiaCanvasWidget`, Panels. Gère l'affichage et les entrées Qt.
    \item \textbf{Application Layer :} `ToolFactory`, `CommandBus`, `EventBus`. Fait le lien entre l'UI et le domaine.
    \item \textbf{Domain Layer :} `Document`, `Layer`, `Tool`, `Filter`. Contient la logique métier pure et les données.
    \item \textbf{Infrastructure Layer :} `SkiaRenderer`, `IOManager`. Implémentations techniques bas niveau.
\end{enumerate}

\subsection{Architecture des Données}
\begin{itemize}
    \item \textbf{Format Pixel :} RGBA 32-bits (0xRRGGBBAA).
    \item \textbf{Gestion Mémoire :} Utilisation intensive de `std::shared_ptr` et `std::unique_ptr`.
    \item \textbf{Historique :} Implémentation via le pattern \textbf{Command}. Chaque action modifiant le document stocke l'état avant/après pour permettre l'annulation (Undo/Redo).
\end{itemize}

\newpage
\subsection{Structure de l'Espace de Travail}

\subsubsection{Arborescence des Fichiers}
L'organisation des fichiers du projet est structurée pour séparer clairement les interfaces (headers) des implémentations, ainsi que les tests et les ressources :

\begin{verbatim}
gimp-remake/
|-- include/           # Déclarations publiques (.h)
|   |-- core/          # Logique métier (outils, commandes)
|   |-- ui/            # Composants graphiques Qt
|   |-- render/        # Moteur de rendu
|   |-- io/            # Entrées/Sorties fichiers
|-- src/               # Implémentations (.cpp)
|   |-- main.cpp       # Point d'entrée de l'application
|   |-- ...            # Structure miroir de include/
|-- tests/             # Suite de tests
|   |-- unit/          # Tests unitaires purs
|   |-- integration/   # Tests avec I/O ou rendu
|-- scripts/           # Scripts de build et maintenance
|-- resources/         # Assets et configurations
|-- docs/              # Documentation technique
\end{verbatim}

\subsubsection{Conventions de Nommage}
Le projet applique des conventions strictes pour faciliter la navigation et la maintenance :

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Type} & \textbf{Format} & \textbf{Exemple} \\
\hline
Fichiers & \texttt{snake\_case} & \texttt{brush\_tool.h}, \texttt{main\_window.cpp} \\
Classes & \texttt{PascalCase} & \texttt{BrushTool}, \texttt{MainWindow} \\
Fonctions/Méthodes & \texttt{camelCase} & \texttt{addLayer()}, \texttt{setColor()} \\
Tests & \texttt{test\_<nom>} & \texttt{test\_history.cpp} \\
\hline
\end{tabular}
\end{center}

\subsection{Algorithmes Clés}
\begin{itemize}
    \item \textbf{Compositing :} Opérations alpha "Porter-Duff" (Over, Source-Over) pour la gestion de la transparence.
    \item \textbf{Flood Fill :} Algorithme par scanline (lignes de balayage) pour le remplissage de zones contiguës.
    \item \textbf{Flou :} Convolution séparable (passes horizontale puis verticale) pour optimiser la complexité algorithmique en $O(n \cdot k)$ au lieu de $O(n \cdot k^2)$.
    \item \textbf{Interpolation :} Bilinéaire pour la mise à l'échelle et le rendu fluide.
    \item \textbf{Conversion Couleur :} Transformations RGB $\leftrightarrow$ HSV pour le sélecteur de couleurs.
\end{itemize}

\subsection{Tests et Qualité}
\begin{itemize}
    \item \textbf{Unit Testing :} Framework Catch2 v3.
    \item \textbf{Intégration Continue (CI) :} Workflows GitHub Actions pour la compilation, le formatage (`clang-format`) et l'analyse statique (`clang-tidy`).
\end{itemize}

\section{Suivi du Projet et Livrables}

\subsection{Organisation des Milestones}
Le développement est découpé en jalons (milestones) incrémentaux pour assurer une livraison continue de fonctionnalités.

\begin{description}
    \item[v0.1.0 - Fondations :] Mise en place de l'architecture cœur.
    \begin{itemize}
        \item Pipeline de rendu (Core Rendering) et composition de calques.
        \item Squelette de l'interface graphique (Shell & Docking) en Qt6.
        \item Système d'historique (Undo/Redo) via le pattern Command.
        \item Gestion des fichiers (Image I/O) et toile interactive (Canvas).
        \item Architecture de gestion d'erreurs et intégration continue (CI).
    \end{itemize}

    \item[v0.2.0 - Outils de Dessin :] Premiers outils créatifs.
    \begin{itemize}
        \item Implémentation des outils : Pinceau, Gomme, Pipette, Pot de peinture, Dégradé.
        \item Panneaux d'options d'outils et sélecteur de couleurs.
        \item Raccourcis clavier.
        \item Moteur de filtres de base.
    \end{itemize}

    \item[v0.3.0 - Sélection \& Transformation :] Cœur des outils de manipulation.
    \begin{itemize}
        \item Outils de sélection (Rectangle, Ellipse) et transformations.
        \item Opérations Presse-papier (Copier/Coller).
        \item Gestion des fichiers projets (.json) avec support multi-calques.
        \item HUD de débogage et reporting d'erreurs.
    \end{itemize}
    
    \item[v0.4.0 - Gestion Avancée des Calques :] Consolidation du moteur de composition.
    \begin{itemize}
        \item Verrouillage et visibilité des calques.
        \item Modes de fusion (Blend Modes).
        \item Fusion de calques (Merge Down / Flatten).
        \item Sauvegarde automatique et récupération de session.
    \end{itemize}
    
    \item[v0.5.0 - Outils Avancés :] Enrichissement fonctionnel.
    \item[v1.0.0 - Release Finale :] Version stable complète.
\end{description}

\subsection{Livrables}
\begin{enumerate}
    \item \textbf{Code Source :} Dépôt Git structuré et documenté.
    \item \textbf{Exécutable :} Binaire autonome ("Standalone") pour Windows x64.
    \item \textbf{Documentation Technique :}
    \begin{itemize}
        \item \texttt{ARCHITECTURE.md} : Guide d'architecture et de maintenance.
        \item Documentation API générée par Doxygen.
    \end{itemize}
    \item \textbf{Rapport de Tests :} Couverture de code (> 50\%) et résultats des tests unitaires/intégration.
\end{enumerate}

\subsection{Organisation du Développement et Qualité}

\subsubsection{Workflow de Collaboration}
Le projet suit un flux de travail rigoureux pour garantir la stabilité de la branche principale :
\begin{itemize}
    \item \textbf{Protection de la branche `main` :} Aucune modification directe n'est autorisée. Tout changement doit passer par une \textbf{Pull Request (PR)}.
    \item \textbf{Branche par Issue :} Chaque fonctionnalité ou correctif doit être développé sur une branche dédiée, liée à une issue spécifique (ex: \texttt{feature/60-rect-select}).
    \item \textbf{Conventional Commits :} Les messages de commit doivent respecter la convention \textit{Conventional Commits} (ex: \texttt{feat: add brush tool}, \texttt{fix: crash on undo}) pour faciliter la génération automatique du changelog.
\end{itemize}

\subsubsection{Stratégie QA et CI/CD}
L'assurance qualité repose sur une double validation, locale et distante :

\textbf{1. Validation Locale (Scripts)}
Avant toute soumission, le développeur doit valider son code via les scripts fournis :
\begin{itemize}
    \item \texttt{scripts/run-format.ps1} : Formatage automatique du code (Clang-Format).
    \item \texttt{scripts/run-lint.ps1} : Analyse statique et détection de bugs potentiels (Clang-Tidy).
\end{itemize}

\textbf{2. Pipeline d'Intégration Continue (GitHub Actions)}
À chaque Pull Request, le pipeline CI exécute automatiquement :
\begin{itemize}
    \item Compilation sous Windows (plateforme cible principale).
    \item Vérification du respect du formatage et absence de warnings du linter.
    \item Exécution complète de la suite de tests (Unitaires et Intégration).
    \item Génération d'un rapport de couverture de code (Cible : > 50\%).
\end{itemize}

\end{document}